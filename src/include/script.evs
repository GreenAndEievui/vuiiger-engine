typedef string = u16;

struct sprite {
	x: u8,
	y: u8,
	tile: u8,
	attributes: u8,
}

#asm
	include "defines.inc"
	include "format.inc";

def PLAYER equ 0
def PARTNER equ 1
def SELF equ -1

macro farstub
	def _yet equs "macro \1\ndb script@_\1\ndb bank(\\1)\ndw \\1\nendm"
	_yet
	purge _yet
endm

	farstub enter_dungeon
	farstub enter_dungeon_immediately
	farstub init_dungeon
	farstub init_dungeon_immediately
	farstub farjmp
	farstub set_scene_tick

; Please note the order of the data in this macro.
; This MAY NOT be generated by `farstub`!!!!!!!!
macro play_music
	db script@_play_music
	dw \1
	db bank(\1)
endm

macro spawn_npc
	db script@_spawn_npc
	db high(wEntity0) + \1
	db bank(\2)
	dw \2
endm

macro set_position
	def x = (\2) | ((\3) << 8)
	def y = (\4) | ((\5) << 8)

	db script@npc_set
	db \1
	db Entity_SpriteX
	db low(x << 4)
	db script@npc_set
	db \1
	db Entity_SpriteX + 1
	db high(x << 4)
	db script@npc_set
	db \1
	db Entity_SpriteY
	db low(y << 4)
	db script@npc_set
	db \1
	db Entity_SpriteY + 1
	db high(y << 4)

	purge x, y
endm

macro say_no_wait
	if !strcmp("\1", "Luvui")
		def name equs "xLuvui.name"
		def voice equs "sfxLuvuiVoice"
	elif !strcmp("\1", "Aris")
		def name equs "xAris.name"
		def voice equs "sfxArisVoice"
	elif !strcmp("\1", "Mom")
		def name equs "xMom.name"
		def voice equs "sfxMomVoice"
	elif !strcmp("\1", "Sephone")
		def name equs "xSephone.name"
		def voice equs "sfxSephoneVoice"
	elif !strcmp("\1", "Libera")
		def name equs "xLibera.name"
		def voice equs "sfxLiberaVoice"
	else
		if !def(_name_\1)
			warn "There is no voice associated with \"\1\"."
			if !def(_say_index)
				def _say_index = -1
			endc
			def _say_index += 1
			pushs
			section "{__EVSCRIPT_FILE__} {_say_index}", romx
			_name_\1: db "\1", 0
			pops
		endc
		def name equs "_name_\1"
		def voice equs "sfxGenericVoice"
	endc

	db script@_say, bank(name), low(name), high(name), \2, \3, low(voice), high(voice)
	purge name, voice
endm

macro say
	say_no_wait \1, \2, \3
	db script@print_wait
endm

macro long_sleep
	def i = \2
	rept 256
		if i > 255
			db script@put_u8, \1, 255
			db script@sleep, \1
			def i -= 255
		else
			break
		endc
	endr
	db script@put_u8, \1, i
	db script@sleep, \1
	purge i
endm

macro npc_dmove
	db script@npc_set, (\1), Entity_Direction, (\2)
	if (\2) == UP
		db npc@npc_move, \1
		dw -(\3), 0
	elif (\2) == RIGHT
		db npc@npc_move, \1
		dw 0, (\3)
	elif (\2) == LEFT
		db npc@npc_move, \1
		dw 0, -(\3)
	else
		db npc@npc_move, \1
		dw (\3), 0
	endc
endm

macro scene_image_load
	db script@_scene_image_load
	; data
	dw \1.dataEnd - \1.data
	dw \1.data
	; map
	; constant size
	dw \1.map
	db bank(\1)
	; colors
	dw \1.colorEnd - \1.color
	dw \1.color
	; color map
	; constant size
	dw \1.colorMap
endm

#end

env script {
	def ret();
	def yld();
	def jmp();
	def jmp_if_true();
	def jmp_if_false();
	def put_u8(); alias put_i8() = put_u8();
	def mov_u8(); alias mov_i8() = mov_u8();
	def add_u8(); alias add_i8() = add_u8();
	def sub_u8(); alias sub_i8() = sub_u8();
	def band_u8(); alias band_i8() = band_u8();
	def equ_u8(); alias equ_i8() = equ_u8();
	def nequ_u8(); alias nequ_i8() = nequ_u8();
	def lt_u8(); alias lt_i8() = lt_u8();
	def gt_u8(); alias gt_i8() = gt_u8();
	def lte_u8(); alias lte_i8() = lte_u8();
	def gte_u8(); alias gte_i8() = gte_u8();
	def land_u8(); alias land_i8() = land_u8();
	def lor_u8(); alias lor_i8() = lor_u8();

	// Engine extensions
	def sleep(u8);
	macro long_sleep(u8, const u8) = long_sleep;
	def rand(return u8);
	def rand_range(u8, u8, return u8);
	def is_cgb(return u8);
	def _farjmp();
	macro farjmp(const u8) = farjmp;

	def print(const string);
	def _play_music();
	macro play_music(const u8) = play_music;
	// Same as print, but sets a delay on each letter.
	// The delay only works within scenes.
	def _say(const string, const string);
	macro say(const u8, const string) = say;
	macro say_no_wait(const u8, const string) = say_no_wait;
	// Wait until text printing is done.
	def print_wait();
	def get_flag(u8, return u8);
	def set_flag(u8, const u8);
	def map_put_tile(u8, u8, u8);
	def map_get_tile(u8, u8, return u8);
	def step_direction(u8, u8, u8);
	def map_3x3_is_clear(u8, u8, return u8);
	def draw_sprite(sprite);

	// NPC functions
	def _spawn_npc(const u8, const u8);
	macro spawn_npc(const u8, const u8) = spawn_npc;
	def npc_move(const u8, const u16, const u16);
	def npc_set(const u8, const u8, const u8);
	def npc_special_frame(const u8);
	def _scene_image_load();

	def _enter_dungeon();
	macro enter_dungeon(const u8) = enter_dungeon;
	def _enter_dungeon_immediately();
	macro enter_dungeon_immediately(const u8) = enter_dungeon_immediately;
	def _init_dungeon();
	macro init_dungeon(const u8) = init_dungeon;
	def _init_dungeon_immediately();
	macro init_dungeon_immediately(const u8) = init_dungeon_immediately;
	def fade_to_black();
	def fade_to_white();
	def fade_in();
	def check_fade(return u8);
	def open_map();
	def open_map_immediately();
	def open_trader(const u16);
	def _set_scene_tick();
	macro set_scene_tick(const u8) = set_scene_tick;
	def _join();
	def _spawn(const u16);

	pool = 18;
}

env npc {
	use script;

	// Self commands
	alias move(const u8, const u16, const u16) = npc_move($1, $3, $2);
	macro dmove(const u8, const u8, const u16) = npc_dmove;
	alias set(const u8, const u8, const u8) = npc_set($1, $2, $3);
	alias frame(const u8, const u8) = npc_set($1, const Entity_Frame, $2);
	alias special_frame(const u8) = npc_special_frame($1);
	alias direction(const u8, const u8) = npc_set($1, const Entity_Direction, $2);
	macro position(const u8, const u16, const u16) = set_position;
	macro load(const u8) = scene_image_load;
	// Toggle the player's ability to move.
	alias lock() = npc_lock();
	// Wait for the current print/say command to end.
	alias wait() = print_wait();

	alias join() = _join();
	alias spawn(const u16) = spawn($1);

	pool = 8;
}
