typedef string = u16;
typedef ptr = u16;

struct sprite {
	x: u8,
	y: u8,
	tile: u8,
	attributes: u8,
}

#asm

def PLAYER equ 0
def PARTNER equ 1
def SELF equ -1

macro play_music
	db script@_play_music
	dw \1
	db bank(\1)
endm
macro enter_dungeon
	db script@_enter_dungeon
	db bank(\1)
	dw \1
endm
macro enter_dungeon_immediately
	db script@_enter_dungeon_immediately
	db bank(\1)
	dw \1
endm
macro set_position
	def x = (\2) | ((\3) << 8)
	def y = (\4) | ((\5) << 8)

	db script@npc_set
	db \1
	db Entity_SpriteX
	db low(x << 4)
	db script@npc_set
	db \1
	db Entity_SpriteX + 1
	db high(x << 4)
	db script@npc_set
	db \1
	db Entity_SpriteY
	db low(y << 4)
	db script@npc_set
	db \1
	db Entity_SpriteY + 1
	db high(y << 4)

	purge x, y
endm
macro say
	db script@_say, \1, \2, \3, \4
	db script@print_wait
endm
#end

env script {
	def ret();
	def yld();
	def jmp();
	def jmp_if_true();
	def jmp_if_false();
	def put_u8(); alias put_i8() = put_u8();
	def mov_u8(); alias mov_i8() = mov_u8();
	def add_u8(); alias add_i8() = add_u8();
	def sub_u8(); alias sub_i8() = sub_u8();
	def band_u8(); alias band_i8() = band_u8();
	def equ_u8(); alias equ_i8() = equ_u8();
	def nequ_u8(); alias nequ_i8() = nequ_u8();
	def lt_u8(); alias lt_i8() = lt_u8();
	def gt_u8(); alias gt_i8() = gt_u8();
	def lte_u8(); alias lte_i8() = lte_u8();
	def gte_u8(); alias gte_i8() = gte_u8();
	def land_u8(); alias land_i8() = land_u8();
	def lor_u8(); alias lor_i8() = lor_u8();

	// Engine extensions
	def rand(return u8);
	def rand_range(const u8, const u8, return u8);
	def is_cgb(return u8);
	def print(const string);
	def _play_music();
	macro play_music(const u8) = play_music;
	// Same as print, but sets a delay on each letter.
	// The delay only works within scenes.
	def _say(const string, const string);
	macro say(const string, const string) = say;
	// Wait until text printing is done.
	def print_wait();
	def get_flag(u8, return u8);
	def set_flag(u8, const u8);
	def map_put_tile(u8, u8, u8);
	def map_get_tile(u8, u8, return u8);
	def step_direction(u8, u8, u8);
	def map_3x3_is_clear(u8, u8, return u8);
	def draw_sprite(sprite);

	// NPC functions
	def npc_move(const u8, const u16, const u16);
	def npc_set(const u8, const u8, const u8);
	def npc_lock();
	def face_player();

	def _enter_dungeon();
	macro enter_dungeon(const u8) = enter_dungeon;
	def _enter_dungeon_immediately();
	macro enter_dungeon_immediately(const u8) = enter_dungeon_immediately;

	pool = 18;
}

env npc {
	use script;

	// Self commands
	alias move(const u16, const u16) = npc_move(const -1, $2, $1);
	alias set(const u8, const u8) = npc_set(const -1, $1, $2);
	alias set_frame(const u8) = npc_set(const -1, const Entity_Frame, $1);
	alias set_direction(const u8) = npc_set(const -1, const Entity_Direction, $1);
	// Player commands
	alias move_player(const u16, const u16) = npc_move(const 0, $2, $1);
	alias set_player(const u8, const u8) = npc_set(const 0, $1, $2);
	alias set_frame_player(const u8) = npc_set(const 0, const Entity_Frame, $1);
	alias set_direction_player(const u8) = npc_set(const 0, const Entity_Direction, $1);
	// Partner commands
	alias move_partner(const u16, const u16) = npc_move(const 1, $2, $1);
	alias set_partner(const u8, const u8) = npc_set(const 1, $1, $2);
	alias set_frame_partner(const u8) = npc_set(const 1, const Entity_Frame, $1);
	alias set_direction_partner(const u8) = npc_set(const 1, const Entity_Direction, $1);
	// Generic commands
	alias move_other(const u8, const u8, const u8) = npc_move($1, $3, $2);
	alias set_frame_other(u8, u8) = npc_set($1, const Entity_Frame, $2);
	alias set_direction_other(u8, u8) = npc_set($1, const Entity_Direction, $2);
	macro set_position(const u8, const u16, const u16) = set_position;
	// Toggle the player's ability to move.
	alias lock() = npc_lock();
	// Wait for the current print/say command to end.
	alias wait() = print_wait();

	pool = 8;
}
